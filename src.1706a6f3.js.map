{"version":3,"sources":["section.ts","../src/lib/directive.ts","../src/lib/dom.ts","../src/lib/part.ts","../src/lib/template.ts","../src/lib/template-instance.ts","../src/lib/template-result.ts","../src/lib/parts.ts","../src/lib/default-template-processor.ts","../src/lib/template-factory.ts","../src/lib/render.ts","src/lit-html.ts","../src/directives/class-map.ts","../../src/common/Component.ts","../../src/common/index.ts","../../src/Button/Button.ts","../../src/Button/index.ts","../../src/Text/Text.ts","../../src/Text/index.ts","../src/directives/style-map.ts","../../src/common/list-item-template.ts","../../src/common/selection-single.ts","../../src/Dropdown/Dropdown.ts","../../src/Dropdown/index.ts","../../src/Table/header-row-template.ts","../src/directives/repeat.ts","../../src/Table/cell-actions-template.ts","../../src/Table/cell-template.ts","../../src/Table/body-template.ts","../../src/Table/Table.js","../../src/Table/index.js","../../src/index.ts","table.js","index.ts"],"names":["Table","props","_rowIdBuilder","rowIdBuilder","idGenerator","state","data","buildForList","_handleOnChange","bind","_updateRowData","_cellRefs","_cellsRenderer","columns","map","cell","Component","keyField","html","onChange","el","_renderCells","tableData","rowsEl","querySelectorAll","forEach","rowEl","rowIndex","rowData","rowId","__tableRowId","updateRowData","cellsEl","renderer","index","cellEl","isRenderer","_renderCell","cellInstance","cellRefs","dataset","ref","element","init","table","appendChild","Math","random","update","type","buildForObject","defaultRowData","setState","trigger","rowDataToMerge","row","id","newId","obj","list","item","container","tableSection","appendTo","x","color","r","g","b","startDate","Date","header","accessor","rgbCell","fieldName","jqDateCell","bgColor","outputCell","actions","render","$el","$","find","each","inputEl","name","on","e","val","get","$datepicker","datepicker","css","width","backgroundColor","_$start","_$end","_$color","_$el","endDate","text","formatDate","colorArr","rgbStr","join"],"mappings":"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","file":"src.1706a6f3.js","sourceRoot":"../src","sourcesContent":["export const createSection = title => {\n  const container = document.createElement('section');\n  container.innerHTML = `<h2 class=\"js-title\"></h2><div class=\"js-body\"></div>`;\n\n  const titleEl = container.querySelector('.js-title');\n  titleEl.textContent = title;\n\n  const body = container.querySelector('.js-body');\n\n  return {\n    appendTo(el: HTMLElement) {\n      el.append(container);\n      return this;\n    },\n    appendChild(el: HTMLElement) {\n      body.appendChild(el);\n      return this;\n    }\n  };\n};\n","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * @module lit-html\n */\n\nimport {Part} from './part.js';\n\nconst directives = new WeakMap<object, true>();\n\n// tslint:disable-next-line:no-any\nexport type DirectiveFactory = (...args: any[]) => object;\n\nexport type DirectiveFn = (part: Part) => void;\n\n/**\n * Brands a function as a directive so that lit-html will call the function\n * during template rendering, rather than passing as a value.\n *\n * @param f The directive factory function. Must be a function that returns a\n * function of the signature `(part: Part) => void`. The returned function will\n * be called with the part object\n *\n * @example\n *\n * ```\n * import {directive, html} from 'lit-html';\n *\n * const immutable = directive((v) => (part) => {\n *   if (part.value !== v) {\n *     part.setValue(v)\n *   }\n * });\n * ```\n */\n// tslint:disable-next-line:no-any\nexport const directive = <F extends DirectiveFactory>(f: F): F =>\n    ((...args: unknown[]) => {\n      const d = f(...args);\n      directives.set(d, true);\n      return d;\n    }) as F;\n\nexport const isDirective = (o: unknown): o is DirectiveFn => {\n  return typeof o === 'function' && directives.has(o);\n};\n","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * @module lit-html\n */\n\ninterface MaybePolyfilledCe extends CustomElementRegistry {\n  polyfillWrapFlushCallback?: object;\n}\n\n/**\n * True if the custom elements polyfill is in use.\n */\nexport const isCEPolyfill = window.customElements !== undefined &&\n    (window.customElements as MaybePolyfilledCe).polyfillWrapFlushCallback !==\n        undefined;\n\n/**\n * Reparents nodes, starting from `startNode` (inclusive) to `endNode`\n * (exclusive), into another container (could be the same container), before\n * `beforeNode`. If `beforeNode` is null, it appends the nodes to the\n * container.\n */\nexport const reparentNodes =\n    (container: Node,\n     start: Node|null,\n     end: Node|null = null,\n     before: Node|null = null): void => {\n      let node = start;\n      while (node !== end) {\n        const n = node!.nextSibling;\n        container.insertBefore(node!, before as Node);\n        node = n;\n      }\n    };\n\n/**\n * Removes nodes, starting from `startNode` (inclusive) to `endNode`\n * (exclusive), from `container`.\n */\nexport const removeNodes =\n    (container: Node, startNode: Node|null, endNode: Node|null = null):\n        void => {\n          let node = startNode;\n          while (node !== endNode) {\n            const n = node!.nextSibling;\n            container.removeChild(node!);\n            node = n;\n          }\n        };\n","/**\n * @license\n * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * @module lit-html\n */\n\n/**\n * The Part interface represents a dynamic part of a template instance rendered\n * by lit-html.\n */\nexport interface Part {\n  value: unknown;\n\n  /**\n   * Sets the current part value, but does not write it to the DOM.\n   * @param value The value that will be committed.\n   */\n  setValue(value: unknown): void;\n\n  /**\n   * Commits the current part value, cause it to actually be written to the DOM.\n   */\n  commit(): void;\n}\n\n/**\n * A sentinel value that signals that a value was handled by a directive and\n * should not be written to the DOM.\n */\nexport const noChange: object = {};\n\n/**\n * A sentinel value that signals a NodePart to fully clear its content.\n */\nexport const nothing = {};\n","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * @module lit-html\n */\n\nimport {TemplateResult} from './template-result.js';\n\n/**\n * An expression marker with embedded unique key to avoid collision with\n * possible text in templates.\n */\nexport const marker = `{{lit-${String(Math.random()).slice(2)}}}`;\n\n/**\n * An expression marker used text-positions, multi-binding attributes, and\n * attributes with markup-like text values.\n */\nexport const nodeMarker = `<!--${marker}-->`;\n\nexport const markerRegex = new RegExp(`${marker}|${nodeMarker}`);\n\n/**\n * Suffix appended to all bound attribute names.\n */\nexport const boundAttributeSuffix = '$lit$';\n\n/**\n * An updateable Template that tracks the location of dynamic parts.\n */\nexport class Template {\n  parts: TemplatePart[] = [];\n  element: HTMLTemplateElement;\n\n  constructor(result: TemplateResult, element: HTMLTemplateElement) {\n    this.element = element;\n    let index = -1;\n    let partIndex = 0;\n    const nodesToRemove: Node[] = [];\n    const _prepareTemplate = (template: HTMLTemplateElement) => {\n      const content = template.content;\n      // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be\n      // null\n      const walker = document.createTreeWalker(\n          content,\n          133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */,\n          null,\n          false);\n      // Keeps track of the last index associated with a part. We try to delete\n      // unnecessary nodes, but we never want to associate two different parts\n      // to the same index. They must have a constant node between.\n      let lastPartIndex = 0;\n      while (walker.nextNode()) {\n        index++;\n        const node = walker.currentNode as Element | Comment | Text;\n        if (node.nodeType === 1 /* Node.ELEMENT_NODE */) {\n          if ((node as Element).hasAttributes()) {\n            const attributes = (node as Element).attributes;\n            // Per\n            // https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap,\n            // attributes are not guaranteed to be returned in document order.\n            // In particular, Edge/IE can return them out of order, so we cannot\n            // assume a correspondance between part index and attribute index.\n            let count = 0;\n            for (let i = 0; i < attributes.length; i++) {\n              if (attributes[i].value.indexOf(marker) >= 0) {\n                count++;\n              }\n            }\n            while (count-- > 0) {\n              // Get the template literal section leading up to the first\n              // expression in this attribute\n              const stringForPart = result.strings[partIndex];\n              // Find the attribute name\n              const name = lastAttributeNameRegex.exec(stringForPart)![2];\n              // Find the corresponding attribute\n              // All bound attributes have had a suffix added in\n              // TemplateResult#getHTML to opt out of special attribute\n              // handling. To look up the attribute value we also need to add\n              // the suffix.\n              const attributeLookupName =\n                  name.toLowerCase() + boundAttributeSuffix;\n              const attributeValue =\n                  (node as Element).getAttribute(attributeLookupName)!;\n              const strings = attributeValue.split(markerRegex);\n              this.parts.push({type: 'attribute', index, name, strings});\n              (node as Element).removeAttribute(attributeLookupName);\n              partIndex += strings.length - 1;\n            }\n          }\n          if ((node as Element).tagName === 'TEMPLATE') {\n            _prepareTemplate(node as HTMLTemplateElement);\n          }\n        } else if (node.nodeType === 3 /* Node.TEXT_NODE */) {\n          const data = (node as Text).data!;\n          if (data.indexOf(marker) >= 0) {\n            const parent = node.parentNode!;\n            const strings = data.split(markerRegex);\n            const lastIndex = strings.length - 1;\n            // Generate a new text node for each literal section\n            // These nodes are also used as the markers for node parts\n            for (let i = 0; i < lastIndex; i++) {\n              parent.insertBefore(\n                  (strings[i] === '') ? createMarker() :\n                                        document.createTextNode(strings[i]),\n                  node);\n              this.parts.push({type: 'node', index: ++index});\n            }\n            // If there's no text, we must insert a comment to mark our place.\n            // Else, we can trust it will stick around after cloning.\n            if (strings[lastIndex] === '') {\n              parent.insertBefore(createMarker(), node);\n              nodesToRemove.push(node);\n            } else {\n              (node as Text).data = strings[lastIndex];\n            }\n            // We have a part for each match found\n            partIndex += lastIndex;\n          }\n        } else if (node.nodeType === 8 /* Node.COMMENT_NODE */) {\n          if ((node as Comment).data === marker) {\n            const parent = node.parentNode!;\n            // Add a new marker node to be the startNode of the Part if any of\n            // the following are true:\n            //  * We don't have a previousSibling\n            //  * The previousSibling is already the start of a previous part\n            if (node.previousSibling === null || index === lastPartIndex) {\n              index++;\n              parent.insertBefore(createMarker(), node);\n            }\n            lastPartIndex = index;\n            this.parts.push({type: 'node', index});\n            // If we don't have a nextSibling, keep this node so we have an end.\n            // Else, we can remove it to save future costs.\n            if (node.nextSibling === null) {\n              (node as Comment).data = '';\n            } else {\n              nodesToRemove.push(node);\n              index--;\n            }\n            partIndex++;\n          } else {\n            let i = -1;\n            while ((i = (node as Comment).data!.indexOf(marker, i + 1)) !==\n                   -1) {\n              // Comment node has a binding marker inside, make an inactive part\n              // The binding won't work, but subsequent bindings will\n              // TODO (justinfagnani): consider whether it's even worth it to\n              // make bindings in comments work\n              this.parts.push({type: 'node', index: -1});\n            }\n          }\n        }\n      }\n    };\n    _prepareTemplate(element);\n    // Remove text binding nodes after the walk to not disturb the TreeWalker\n    for (const n of nodesToRemove) {\n      n.parentNode!.removeChild(n);\n    }\n  }\n}\n\n/**\n * A placeholder for a dynamic expression in an HTML template.\n *\n * There are two built-in part types: AttributePart and NodePart. NodeParts\n * always represent a single dynamic expression, while AttributeParts may\n * represent as many expressions are contained in the attribute.\n *\n * A Template's parts are mutable, so parts can be replaced or modified\n * (possibly to implement different template semantics). The contract is that\n * parts can only be replaced, not removed, added or reordered, and parts must\n * always consume the correct number of values in their `update()` method.\n *\n * TODO(justinfagnani): That requirement is a little fragile. A\n * TemplateInstance could instead be more careful about which values it gives\n * to Part.update().\n */\nexport type TemplatePart = {\n  type: 'node',\n  index: number\n}|{type: 'attribute', index: number, name: string, strings: string[]};\n\nexport const isTemplatePartActive = (part: TemplatePart) => part.index !== -1;\n\n// Allows `document.createComment('')` to be renamed for a\n// small manual size-savings.\nexport const createMarker = () => document.createComment('');\n\n/**\n * This regex extracts the attribute name preceding an attribute-position\n * expression. It does this by matching the syntax allowed for attributes\n * against the string literal directly preceding the expression, assuming that\n * the expression is in an attribute-value position.\n *\n * See attributes in the HTML spec:\n * https://www.w3.org/TR/html5/syntax.html#attributes-0\n *\n * \"\\0-\\x1F\\x7F-\\x9F\" are Unicode control characters\n *\n * \" \\x09\\x0a\\x0c\\x0d\" are HTML space characters:\n * https://www.w3.org/TR/html5/infrastructure.html#space-character\n *\n * So an attribute is:\n *  * The name: any character except a control character, space character, ('),\n *    (\"), \">\", \"=\", or \"/\"\n *  * Followed by zero or more space characters\n *  * Followed by \"=\"\n *  * Followed by zero or more space characters\n *  * Followed by:\n *    * Any character except space, ('), (\"), \"<\", \">\", \"=\", (`), or\n *    * (\") then any non-(\"), or\n *    * (') then any non-(')\n */\nexport const lastAttributeNameRegex =\n    /([ \\x09\\x0a\\x0c\\x0d])([^\\0-\\x1F\\x7F-\\x9F \\x09\\x0a\\x0c\\x0d\"'>=/]+)([ \\x09\\x0a\\x0c\\x0d]*=[ \\x09\\x0a\\x0c\\x0d]*(?:[^ \\x09\\x0a\\x0c\\x0d\"'`<>=]*|\"[^\"]*|'[^']*))$/;\n","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * @module lit-html\n */\n\nimport {isCEPolyfill} from './dom.js';\nimport {Part} from './part.js';\nimport {RenderOptions} from './render-options.js';\nimport {TemplateProcessor} from './template-processor.js';\nimport {isTemplatePartActive, Template} from './template.js';\n\n/**\n * An instance of a `Template` that can be attached to the DOM and updated\n * with new values.\n */\nexport class TemplateInstance {\n  _parts: Array<Part|undefined> = [];\n  processor: TemplateProcessor;\n  options: RenderOptions;\n  template: Template;\n\n  constructor(\n      template: Template, processor: TemplateProcessor,\n      options: RenderOptions) {\n    this.template = template;\n    this.processor = processor;\n    this.options = options;\n  }\n\n  update(values: unknown[]) {\n    let i = 0;\n    for (const part of this._parts) {\n      if (part !== undefined) {\n        part.setValue(values[i]);\n      }\n      i++;\n    }\n    for (const part of this._parts) {\n      if (part !== undefined) {\n        part.commit();\n      }\n    }\n  }\n\n  _clone(): DocumentFragment {\n    // When using the Custom Elements polyfill, clone the node, rather than\n    // importing it, to keep the fragment in the template's document. This\n    // leaves the fragment inert so custom elements won't upgrade and\n    // potentially modify their contents by creating a polyfilled ShadowRoot\n    // while we traverse the tree.\n    const fragment = isCEPolyfill ?\n        this.template.element.content.cloneNode(true) as DocumentFragment :\n        document.importNode(this.template.element.content, true);\n\n    const parts = this.template.parts;\n    let partIndex = 0;\n    let nodeIndex = 0;\n    const _prepareInstance = (fragment: DocumentFragment) => {\n      // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be\n      // null\n      const walker = document.createTreeWalker(\n          fragment,\n          133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */,\n          null,\n          false);\n      let node = walker.nextNode();\n      // Loop through all the nodes and parts of a template\n      while (partIndex < parts.length && node !== null) {\n        const part = parts[partIndex];\n        // Consecutive Parts may have the same node index, in the case of\n        // multiple bound attributes on an element. So each iteration we either\n        // increment the nodeIndex, if we aren't on a node with a part, or the\n        // partIndex if we are. By not incrementing the nodeIndex when we find a\n        // part, we allow for the next part to be associated with the current\n        // node if neccessasry.\n        if (!isTemplatePartActive(part)) {\n          this._parts.push(undefined);\n          partIndex++;\n        } else if (nodeIndex === part.index) {\n          if (part.type === 'node') {\n            const part = this.processor.handleTextExpression(this.options);\n            part.insertAfterNode(node.previousSibling!);\n            this._parts.push(part);\n          } else {\n            this._parts.push(...this.processor.handleAttributeExpressions(\n                node as Element, part.name, part.strings, this.options));\n          }\n          partIndex++;\n        } else {\n          nodeIndex++;\n          if (node.nodeName === 'TEMPLATE') {\n            _prepareInstance((node as HTMLTemplateElement).content);\n          }\n          node = walker.nextNode();\n        }\n      }\n    };\n    _prepareInstance(fragment);\n    if (isCEPolyfill) {\n      document.adoptNode(fragment);\n      customElements.upgrade(fragment);\n    }\n    return fragment;\n  }\n}\n","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * @module lit-html\n */\n\nimport {reparentNodes} from './dom.js';\nimport {TemplateProcessor} from './template-processor.js';\nimport {boundAttributeSuffix, lastAttributeNameRegex, marker, nodeMarker} from './template.js';\n\n/**\n * The return type of `html`, which holds a Template and the values from\n * interpolated expressions.\n */\nexport class TemplateResult {\n  strings: TemplateStringsArray;\n  values: unknown[];\n  type: string;\n  processor: TemplateProcessor;\n\n  constructor(\n      strings: TemplateStringsArray, values: unknown[], type: string,\n      processor: TemplateProcessor) {\n    this.strings = strings;\n    this.values = values;\n    this.type = type;\n    this.processor = processor;\n  }\n\n  /**\n   * Returns a string of HTML used to create a `<template>` element.\n   */\n  getHTML(): string {\n    const endIndex = this.strings.length - 1;\n    let html = '';\n    for (let i = 0; i < endIndex; i++) {\n      const s = this.strings[i];\n      // This exec() call does two things:\n      // 1) Appends a suffix to the bound attribute name to opt out of special\n      // attribute value parsing that IE11 and Edge do, like for style and\n      // many SVG attributes. The Template class also appends the same suffix\n      // when looking up attributes to create Parts.\n      // 2) Adds an unquoted-attribute-safe marker for the first expression in\n      // an attribute. Subsequent attribute expressions will use node markers,\n      // and this is safe since attributes with multiple expressions are\n      // guaranteed to be quoted.\n      const match = lastAttributeNameRegex.exec(s);\n      if (match) {\n        // We're starting a new bound attribute.\n        // Add the safe attribute suffix, and use unquoted-attribute-safe\n        // marker.\n        html += s.substr(0, match.index) + match[1] + match[2] +\n            boundAttributeSuffix + match[3] + marker;\n      } else {\n        // We're either in a bound node, or trailing bound attribute.\n        // Either way, nodeMarker is safe to use.\n        html += s + nodeMarker;\n      }\n    }\n    return html + this.strings[endIndex];\n  }\n\n  getTemplateElement(): HTMLTemplateElement {\n    const template = document.createElement('template');\n    template.innerHTML = this.getHTML();\n    return template;\n  }\n}\n\n/**\n * A TemplateResult for SVG fragments.\n *\n * This class wraps HTMl in an `<svg>` tag in order to parse its contents in the\n * SVG namespace, then modifies the template to remove the `<svg>` tag so that\n * clones only container the original fragment.\n */\nexport class SVGTemplateResult extends TemplateResult {\n  getHTML(): string {\n    return `<svg>${super.getHTML()}</svg>`;\n  }\n\n  getTemplateElement(): HTMLTemplateElement {\n    const template = super.getTemplateElement();\n    const content = template.content;\n    const svgElement = content.firstChild!;\n    content.removeChild(svgElement);\n    reparentNodes(content, svgElement.firstChild);\n    return template;\n  }\n}\n","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * @module lit-html\n */\n\nimport {isDirective} from './directive.js';\nimport {removeNodes} from './dom.js';\nimport {noChange, nothing, Part} from './part.js';\nimport {RenderOptions} from './render-options.js';\nimport {TemplateInstance} from './template-instance.js';\nimport {TemplateResult} from './template-result.js';\nimport {createMarker} from './template.js';\n\n// https://tc39.github.io/ecma262/#sec-typeof-operator\nexport type Primitive = null|undefined|boolean|number|string|Symbol|bigint;\nexport const isPrimitive = (value: unknown): value is Primitive => {\n  return (\n      value === null ||\n      !(typeof value === 'object' || typeof value === 'function'));\n};\n\n/**\n * Sets attribute values for AttributeParts, so that the value is only set once\n * even if there are multiple parts for an attribute.\n */\nexport class AttributeCommitter {\n  element: Element;\n  name: string;\n  strings: string[];\n  parts: AttributePart[];\n  dirty = true;\n\n  constructor(element: Element, name: string, strings: string[]) {\n    this.element = element;\n    this.name = name;\n    this.strings = strings;\n    this.parts = [];\n    for (let i = 0; i < strings.length - 1; i++) {\n      this.parts[i] = this._createPart();\n    }\n  }\n\n  /**\n   * Creates a single part. Override this to create a differnt type of part.\n   */\n  protected _createPart(): AttributePart {\n    return new AttributePart(this);\n  }\n\n  protected _getValue(): unknown {\n    const strings = this.strings;\n    const l = strings.length - 1;\n    let text = '';\n\n    for (let i = 0; i < l; i++) {\n      text += strings[i];\n      const part = this.parts[i];\n      if (part !== undefined) {\n        const v = part.value;\n        if (v != null &&\n            (Array.isArray(v) ||\n             // tslint:disable-next-line:no-any\n             typeof v !== 'string' && (v as any)[Symbol.iterator])) {\n          for (const t of v as Iterable<unknown>) {\n            text += typeof t === 'string' ? t : String(t);\n          }\n        } else {\n          text += typeof v === 'string' ? v : String(v);\n        }\n      }\n    }\n\n    text += strings[l];\n    return text;\n  }\n\n  commit(): void {\n    if (this.dirty) {\n      this.dirty = false;\n      this.element.setAttribute(this.name, this._getValue() as string);\n    }\n  }\n}\n\nexport class AttributePart implements Part {\n  committer: AttributeCommitter;\n  value: unknown = undefined;\n\n  constructor(comitter: AttributeCommitter) {\n    this.committer = comitter;\n  }\n\n  setValue(value: unknown): void {\n    if (value !== noChange && (!isPrimitive(value) || value !== this.value)) {\n      this.value = value;\n      // If the value is a not a directive, dirty the committer so that it'll\n      // call setAttribute. If the value is a directive, it'll dirty the\n      // committer if it calls setValue().\n      if (!isDirective(value)) {\n        this.committer.dirty = true;\n      }\n    }\n  }\n\n  commit() {\n    while (isDirective(this.value)) {\n      const directive = this.value;\n      this.value = noChange;\n      directive(this);\n    }\n    if (this.value === noChange) {\n      return;\n    }\n    this.committer.commit();\n  }\n}\n\nexport class NodePart implements Part {\n  options: RenderOptions;\n  startNode!: Node;\n  endNode!: Node;\n  value: unknown = undefined;\n  _pendingValue: unknown = undefined;\n\n  constructor(options: RenderOptions) {\n    this.options = options;\n  }\n\n  /**\n   * Inserts this part into a container.\n   *\n   * This part must be empty, as its contents are not automatically moved.\n   */\n  appendInto(container: Node) {\n    this.startNode = container.appendChild(createMarker());\n    this.endNode = container.appendChild(createMarker());\n  }\n\n  /**\n   * Inserts this part between `ref` and `ref`'s next sibling. Both `ref` and\n   * its next sibling must be static, unchanging nodes such as those that appear\n   * in a literal section of a template.\n   *\n   * This part must be empty, as its contents are not automatically moved.\n   */\n  insertAfterNode(ref: Node) {\n    this.startNode = ref;\n    this.endNode = ref.nextSibling!;\n  }\n\n  /**\n   * Appends this part into a parent part.\n   *\n   * This part must be empty, as its contents are not automatically moved.\n   */\n  appendIntoPart(part: NodePart) {\n    part._insert(this.startNode = createMarker());\n    part._insert(this.endNode = createMarker());\n  }\n\n  /**\n   * Appends this part after `ref`\n   *\n   * This part must be empty, as its contents are not automatically moved.\n   */\n  insertAfterPart(ref: NodePart) {\n    ref._insert(this.startNode = createMarker());\n    this.endNode = ref.endNode;\n    ref.endNode = this.startNode;\n  }\n\n  setValue(value: unknown): void {\n    this._pendingValue = value;\n  }\n\n  commit() {\n    while (isDirective(this._pendingValue)) {\n      const directive = this._pendingValue;\n      this._pendingValue = noChange;\n      directive(this);\n    }\n    const value = this._pendingValue;\n    if (value === noChange) {\n      return;\n    }\n    if (isPrimitive(value)) {\n      if (value !== this.value) {\n        this._commitText(value);\n      }\n    } else if (value instanceof TemplateResult) {\n      this._commitTemplateResult(value);\n    } else if (value instanceof Node) {\n      this._commitNode(value);\n    } else if (\n        Array.isArray(value) ||\n        // tslint:disable-next-line:no-any\n        (value as any)[Symbol.iterator]) {\n      this._commitIterable(value as Iterable<unknown>);\n    } else if (value === nothing) {\n      this.value = nothing;\n      this.clear();\n    } else {\n      // Fallback, will render the string representation\n      this._commitText(value);\n    }\n  }\n\n  private _insert(node: Node) {\n    this.endNode.parentNode!.insertBefore(node, this.endNode);\n  }\n\n  private _commitNode(value: Node): void {\n    if (this.value === value) {\n      return;\n    }\n    this.clear();\n    this._insert(value);\n    this.value = value;\n  }\n\n  private _commitText(value: unknown): void {\n    const node = this.startNode.nextSibling!;\n    value = value == null ? '' : value;\n    if (node === this.endNode.previousSibling &&\n        node.nodeType === 3 /* Node.TEXT_NODE */) {\n      // If we only have a single text node between the markers, we can just\n      // set its value, rather than replacing it.\n      // TODO(justinfagnani): Can we just check if this.value is primitive?\n      (node as Text).data = value as string;\n    } else {\n      this._commitNode(document.createTextNode(\n          typeof value === 'string' ? value : String(value)));\n    }\n    this.value = value;\n  }\n\n  private _commitTemplateResult(value: TemplateResult): void {\n    const template = this.options.templateFactory(value);\n    if (this.value instanceof TemplateInstance &&\n        this.value.template === template) {\n      this.value.update(value.values);\n    } else {\n      // Make sure we propagate the template processor from the TemplateResult\n      // so that we use its syntax extension, etc. The template factory comes\n      // from the render function options so that it can control template\n      // caching and preprocessing.\n      const instance =\n          new TemplateInstance(template, value.processor, this.options);\n      const fragment = instance._clone();\n      instance.update(value.values);\n      this._commitNode(fragment);\n      this.value = instance;\n    }\n  }\n\n  private _commitIterable(value: Iterable<unknown>): void {\n    // For an Iterable, we create a new InstancePart per item, then set its\n    // value to the item. This is a little bit of overhead for every item in\n    // an Iterable, but it lets us recurse easily and efficiently update Arrays\n    // of TemplateResults that will be commonly returned from expressions like:\n    // array.map((i) => html`${i}`), by reusing existing TemplateInstances.\n\n    // If _value is an array, then the previous render was of an\n    // iterable and _value will contain the NodeParts from the previous\n    // render. If _value is not an array, clear this part and make a new\n    // array for NodeParts.\n    if (!Array.isArray(this.value)) {\n      this.value = [];\n      this.clear();\n    }\n\n    // Lets us keep track of how many items we stamped so we can clear leftover\n    // items from a previous render\n    const itemParts = this.value as NodePart[];\n    let partIndex = 0;\n    let itemPart: NodePart|undefined;\n\n    for (const item of value) {\n      // Try to reuse an existing part\n      itemPart = itemParts[partIndex];\n\n      // If no existing part, create a new one\n      if (itemPart === undefined) {\n        itemPart = new NodePart(this.options);\n        itemParts.push(itemPart);\n        if (partIndex === 0) {\n          itemPart.appendIntoPart(this);\n        } else {\n          itemPart.insertAfterPart(itemParts[partIndex - 1]);\n        }\n      }\n      itemPart.setValue(item);\n      itemPart.commit();\n      partIndex++;\n    }\n\n    if (partIndex < itemParts.length) {\n      // Truncate the parts array so _value reflects the current state\n      itemParts.length = partIndex;\n      this.clear(itemPart && itemPart!.endNode);\n    }\n  }\n\n  clear(startNode: Node = this.startNode) {\n    removeNodes(\n        this.startNode.parentNode!, startNode.nextSibling!, this.endNode);\n  }\n}\n\n/**\n * Implements a boolean attribute, roughly as defined in the HTML\n * specification.\n *\n * If the value is truthy, then the attribute is present with a value of\n * ''. If the value is falsey, the attribute is removed.\n */\nexport class BooleanAttributePart implements Part {\n  element: Element;\n  name: string;\n  strings: string[];\n  value: unknown = undefined;\n  _pendingValue: unknown = undefined;\n\n  constructor(element: Element, name: string, strings: string[]) {\n    if (strings.length !== 2 || strings[0] !== '' || strings[1] !== '') {\n      throw new Error(\n          'Boolean attributes can only contain a single expression');\n    }\n    this.element = element;\n    this.name = name;\n    this.strings = strings;\n  }\n\n  setValue(value: unknown): void {\n    this._pendingValue = value;\n  }\n\n  commit() {\n    while (isDirective(this._pendingValue)) {\n      const directive = this._pendingValue;\n      this._pendingValue = noChange;\n      directive(this);\n    }\n    if (this._pendingValue === noChange) {\n      return;\n    }\n    const value = !!this._pendingValue;\n    if (this.value !== value) {\n      if (value) {\n        this.element.setAttribute(this.name, '');\n      } else {\n        this.element.removeAttribute(this.name);\n      }\n    }\n    this.value = value;\n    this._pendingValue = noChange;\n  }\n}\n\n/**\n * Sets attribute values for PropertyParts, so that the value is only set once\n * even if there are multiple parts for a property.\n *\n * If an expression controls the whole property value, then the value is simply\n * assigned to the property under control. If there are string literals or\n * multiple expressions, then the strings are expressions are interpolated into\n * a string first.\n */\nexport class PropertyCommitter extends AttributeCommitter {\n  single: boolean;\n\n  constructor(element: Element, name: string, strings: string[]) {\n    super(element, name, strings);\n    this.single =\n        (strings.length === 2 && strings[0] === '' && strings[1] === '');\n  }\n\n  protected _createPart(): PropertyPart {\n    return new PropertyPart(this);\n  }\n\n  _getValue() {\n    if (this.single) {\n      return this.parts[0].value;\n    }\n    return super._getValue();\n  }\n\n  commit(): void {\n    if (this.dirty) {\n      this.dirty = false;\n      // tslint:disable-next-line:no-any\n      (this.element as any)[this.name] = this._getValue();\n    }\n  }\n}\n\nexport class PropertyPart extends AttributePart {}\n\n// Detect event listener options support. If the `capture` property is read\n// from the options object, then options are supported. If not, then the thrid\n// argument to add/removeEventListener is interpreted as the boolean capture\n// value so we should only pass the `capture` property.\nlet eventOptionsSupported = false;\n\ntry {\n  const options = {\n    get capture() {\n      eventOptionsSupported = true;\n      return false;\n    }\n  };\n  // tslint:disable-next-line:no-any\n  window.addEventListener('test', options as any, options);\n  // tslint:disable-next-line:no-any\n  window.removeEventListener('test', options as any, options);\n} catch (_e) {\n}\n\n\ntype EventHandlerWithOptions =\n    EventListenerOrEventListenerObject&Partial<AddEventListenerOptions>;\nexport class EventPart implements Part {\n  element: Element;\n  eventName: string;\n  eventContext?: EventTarget;\n  value: undefined|EventHandlerWithOptions = undefined;\n  _options?: AddEventListenerOptions;\n  _pendingValue: undefined|EventHandlerWithOptions = undefined;\n  _boundHandleEvent: (event: Event) => void;\n\n  constructor(element: Element, eventName: string, eventContext?: EventTarget) {\n    this.element = element;\n    this.eventName = eventName;\n    this.eventContext = eventContext;\n    this._boundHandleEvent = (e) => this.handleEvent(e);\n  }\n\n  setValue(value: undefined|EventHandlerWithOptions): void {\n    this._pendingValue = value;\n  }\n\n  commit() {\n    while (isDirective(this._pendingValue)) {\n      const directive = this._pendingValue;\n      this._pendingValue = noChange as EventHandlerWithOptions;\n      directive(this);\n    }\n    if (this._pendingValue === noChange) {\n      return;\n    }\n\n    const newListener = this._pendingValue;\n    const oldListener = this.value;\n    const shouldRemoveListener = newListener == null ||\n        oldListener != null &&\n            (newListener.capture !== oldListener.capture ||\n             newListener.once !== oldListener.once ||\n             newListener.passive !== oldListener.passive);\n    const shouldAddListener =\n        newListener != null && (oldListener == null || shouldRemoveListener);\n\n    if (shouldRemoveListener) {\n      this.element.removeEventListener(\n          this.eventName, this._boundHandleEvent, this._options);\n    }\n    if (shouldAddListener) {\n      this._options = getOptions(newListener);\n      this.element.addEventListener(\n          this.eventName, this._boundHandleEvent, this._options);\n    }\n    this.value = newListener;\n    this._pendingValue = noChange as EventHandlerWithOptions;\n  }\n\n  handleEvent(event: Event) {\n    if (typeof this.value === 'function') {\n      this.value.call(this.eventContext || this.element, event);\n    } else {\n      (this.value as EventListenerObject).handleEvent(event);\n    }\n  }\n}\n\n// We copy options because of the inconsistent behavior of browsers when reading\n// the third argument of add/removeEventListener. IE11 doesn't support options\n// at all. Chrome 41 only reads `capture` if the argument is an object.\nconst getOptions = (o: AddEventListenerOptions|undefined) => o &&\n    (eventOptionsSupported ?\n         {capture: o.capture, passive: o.passive, once: o.once} :\n         o.capture as AddEventListenerOptions);\n","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * @module lit-html\n */\n\nimport {Part} from './part.js';\nimport {AttributeCommitter, BooleanAttributePart, EventPart, NodePart, PropertyCommitter} from './parts.js';\nimport {RenderOptions} from './render-options.js';\nimport {TemplateProcessor} from './template-processor.js';\n\n/**\n * Creates Parts when a template is instantiated.\n */\nexport class DefaultTemplateProcessor implements TemplateProcessor {\n  /**\n   * Create parts for an attribute-position binding, given the event, attribute\n   * name, and string literals.\n   *\n   * @param element The element containing the binding\n   * @param name  The attribute name\n   * @param strings The string literals. There are always at least two strings,\n   *   event for fully-controlled bindings with a single expression.\n   */\n  handleAttributeExpressions(\n      element: Element, name: string, strings: string[],\n      options: RenderOptions): Part[] {\n    const prefix = name[0];\n    if (prefix === '.') {\n      const comitter = new PropertyCommitter(element, name.slice(1), strings);\n      return comitter.parts;\n    }\n    if (prefix === '@') {\n      return [new EventPart(element, name.slice(1), options.eventContext)];\n    }\n    if (prefix === '?') {\n      return [new BooleanAttributePart(element, name.slice(1), strings)];\n    }\n    const comitter = new AttributeCommitter(element, name, strings);\n    return comitter.parts;\n  }\n  /**\n   * Create parts for a text-position binding.\n   * @param templateFactory\n   */\n  handleTextExpression(options: RenderOptions) {\n    return new NodePart(options);\n  }\n}\n\nexport const defaultTemplateProcessor = new DefaultTemplateProcessor();\n","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * @module lit-html\n */\n\nimport {TemplateResult} from './template-result.js';\nimport {marker, Template} from './template.js';\n\n/**\n * A function type that creates a Template from a TemplateResult.\n *\n * This is a hook into the template-creation process for rendering that\n * requires some modification of templates before they're used, like ShadyCSS,\n * which must add classes to elements and remove styles.\n *\n * Templates should be cached as aggressively as possible, so that many\n * TemplateResults produced from the same expression only do the work of\n * creating the Template the first time.\n *\n * Templates are usually cached by TemplateResult.strings and\n * TemplateResult.type, but may be cached by other keys if this function\n * modifies the template.\n *\n * Note that currently TemplateFactories must not add, remove, or reorder\n * expressions, because there is no way to describe such a modification\n * to render() so that values are interpolated to the correct place in the\n * template instances.\n */\nexport type TemplateFactory = (result: TemplateResult) => Template;\n\n/**\n * The default TemplateFactory which caches Templates keyed on\n * result.type and result.strings.\n */\nexport function templateFactory(result: TemplateResult) {\n  let templateCache = templateCaches.get(result.type);\n  if (templateCache === undefined) {\n    templateCache = {\n      stringsArray: new WeakMap<TemplateStringsArray, Template>(),\n      keyString: new Map<string, Template>()\n    };\n    templateCaches.set(result.type, templateCache);\n  }\n\n  let template = templateCache.stringsArray.get(result.strings);\n  if (template !== undefined) {\n    return template;\n  }\n\n  // If the TemplateStringsArray is new, generate a key from the strings\n  // This key is shared between all templates with identical content\n  const key = result.strings.join(marker);\n\n  // Check if we already have a Template for this key\n  template = templateCache.keyString.get(key);\n  if (template === undefined) {\n    // If we have not seen this key before, create a new Template\n    template = new Template(result, result.getTemplateElement());\n    // Cache the Template for this key\n    templateCache.keyString.set(key, template);\n  }\n\n  // Cache all future queries for this TemplateStringsArray\n  templateCache.stringsArray.set(result.strings, template);\n  return template;\n}\n\n/**\n * The first argument to JS template tags retain identity across multiple\n * calls to a tag for the same literal, so we can cache work done per literal\n * in a Map.\n *\n * Safari currently has a bug which occasionally breaks this behaviour, so we\n * need to cache the Template at two levels. We first cache the\n * TemplateStringsArray, and if that fails, we cache a key constructed by\n * joining the strings array.\n */\nexport type templateCache = {\n  stringsArray: WeakMap<TemplateStringsArray, Template>;\n  keyString: Map<string, Template>;\n};\n\nexport const templateCaches = new Map<string, templateCache>();\n","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * @module lit-html\n */\n\nimport {removeNodes} from './dom.js';\nimport {NodePart} from './parts.js';\nimport {RenderOptions} from './render-options.js';\nimport {templateFactory} from './template-factory.js';\nimport {TemplateResult} from './template-result.js';\n\nexport const parts = new WeakMap<Node, NodePart>();\n\n/**\n * Renders a template to a container.\n *\n * To update a container with new values, reevaluate the template literal and\n * call `render` with the new result.\n *\n * @param result a TemplateResult created by evaluating a template tag like\n *     `html` or `svg`.\n * @param container A DOM parent to render to. The entire contents are either\n *     replaced, or efficiently updated if the same result type was previous\n *     rendered there.\n * @param options RenderOptions for the entire render tree rendered to this\n *     container. Render options must *not* change between renders to the same\n *     container, as those changes will not effect previously rendered DOM.\n */\nexport const render =\n    (result: TemplateResult,\n     container: Element|DocumentFragment,\n     options?: Partial<RenderOptions>) => {\n      let part = parts.get(container);\n      if (part === undefined) {\n        removeNodes(container, container.firstChild);\n        parts.set(container, part = new NodePart({\n                               templateFactory,\n                               ...options,\n                             }));\n        part.appendInto(container);\n      }\n      part.setValue(result);\n      part.commit();\n    };\n","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n/**\n *\n * Main lit-html module.\n *\n * Main exports:\n *\n * -  [[html]]\n * -  [[svg]]\n * -  [[render]]\n *\n * @module lit-html\n * @preferred\n */\n\n/**\n * Do not remove this comment; it keeps typedoc from misplacing the module\n * docs.\n */\nimport {defaultTemplateProcessor} from './lib/default-template-processor.js';\nimport {SVGTemplateResult, TemplateResult} from './lib/template-result.js';\n\nexport {DefaultTemplateProcessor, defaultTemplateProcessor} from './lib/default-template-processor.js';\nexport {directive, DirectiveFn, isDirective} from './lib/directive.js';\n// TODO(justinfagnani): remove line when we get NodePart moving methods\nexport {removeNodes, reparentNodes} from './lib/dom.js';\nexport {noChange, nothing, Part} from './lib/part.js';\nexport {AttributeCommitter, AttributePart, BooleanAttributePart, EventPart, isPrimitive, NodePart, PropertyCommitter, PropertyPart} from './lib/parts.js';\nexport {RenderOptions} from './lib/render-options.js';\nexport {parts, render} from './lib/render.js';\nexport {templateCaches, templateFactory} from './lib/template-factory.js';\nexport {TemplateInstance} from './lib/template-instance.js';\nexport {TemplateProcessor} from './lib/template-processor.js';\nexport {SVGTemplateResult, TemplateResult} from './lib/template-result.js';\nexport {createMarker, isTemplatePartActive, Template} from './lib/template.js';\n\ndeclare global {\n  interface Window {\n    litHtmlVersions: string[];\n  }\n}\n\n// IMPORTANT: do not change the property name or the assignment expression.\n// This line will be used in regexes to search for lit-html usage.\n// TODO(justinfagnani): inject version number at build time\n(window['litHtmlVersions'] || (window['litHtmlVersions'] = [])).push('1.0.0');\n\n/**\n * Interprets a template literal as an HTML template that can efficiently\n * render to and update a container.\n */\nexport const html = (strings: TemplateStringsArray, ...values: unknown[]) =>\n    new TemplateResult(strings, values, 'html', defaultTemplateProcessor);\n\n/**\n * Interprets a template literal as an SVG template that can efficiently\n * render to and update a container.\n */\nexport const svg = (strings: TemplateStringsArray, ...values: unknown[]) =>\n    new SVGTemplateResult(strings, values, 'svg', defaultTemplateProcessor);\n","/**\n * @license\n * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport {AttributePart, directive, Part, PropertyPart} from '../lit-html.js';\n\n\n// On IE11, classList.toggle doesn't accept a second argument.\n// Since this is so minor, we just polyfill it.\nif (window.navigator.userAgent.match('Trident')) {\n  DOMTokenList.prototype.toggle = function(\n      token: string, force?: boolean|undefined) {\n    if (force === undefined || force) {\n      this.add(token);\n    } else {\n      this.remove(token);\n    }\n    return force === undefined ? true : force;\n  };\n}\n\nexport interface ClassInfo {\n  [name: string]: string|boolean|number;\n}\n\n/**\n * Stores the ClassInfo object applied to a given AttributePart.\n * Used to unset existing values when a new ClassInfo object is applied.\n */\nconst classMapCache = new WeakMap();\n\n/**\n * Stores AttributeParts that have had static classes applied (e.g. `foo` in\n * class=\"foo ${classMap()}\"). Static classes are applied only the first time\n * the directive is run on a part.\n */\n// Note, could be a WeakSet, but prefer not requiring this polyfill.\nconst classMapStatics = new WeakMap();\n\n/**\n * A directive that applies CSS classes. This must be used in the `class`\n * attribute and must be the only part used in the attribute. It takes each\n * property in the `classInfo` argument and adds the property name to the\n * element's `classList` if the property value is truthy; if the property value\n * is falsey, the property name is removed from the element's `classList`. For\n * example\n * `{foo: bar}` applies the class `foo` if the value of `bar` is truthy.\n * @param classInfo {ClassInfo}\n */\nexport const classMap = directive((classInfo: ClassInfo) => (part: Part) => {\n  if (!(part instanceof AttributePart) || (part instanceof PropertyPart) ||\n      part.committer.name !== 'class' || part.committer.parts.length > 1) {\n    throw new Error(\n        'The `classMap` directive must be used in the `class` attribute ' +\n        'and must be the only part in the attribute.');\n  }\n  // handle static classes\n  if (!classMapStatics.has(part)) {\n    part.committer.element.className = part.committer.strings.join(' ');\n    classMapStatics.set(part, true);\n  }\n  // remove old classes that no longer apply\n  const oldInfo = classMapCache.get(part);\n  for (const name in oldInfo) {\n    if (!(name in classInfo)) {\n      part.committer.element.classList.remove(name);\n    }\n  }\n  // add new classes\n  for (const name in classInfo) {\n    if (!oldInfo || (oldInfo[name] !== classInfo[name])) {\n      // We explicitly want a loose truthy check here because\n      // it seems more convenient that '' and 0 are skipped.\n      part.committer.element.classList.toggle(name, Boolean(classInfo[name]));\n    }\n  }\n  classMapCache.set(part, classInfo);\n});\n","import { render, TemplateResult } from 'lit-html';\n\nconst lcfirst = (str: string) => {\n  const firstChar = str.charAt(0).toLowerCase();\n  return firstChar + str.substr(1);\n};\n\nexport default class Component {\n  _fragmentEl: DocumentFragment;\n  _el: HTMLElement;\n  _eventsToBind: Object;\n  state: Object;\n\n  constructor(props = {}) {\n    this._fragmentEl = null;\n    this._el = null;\n    this._eventsToBind = {};\n    this._bindEventsFromProps(props);\n    this.state = props;\n  }\n\n  template(props = {}): TemplateResult {\n    throw new Error('You have to implement the method \"template\".');\n  }\n\n  get fragmentEl() {\n    if (!this._fragmentEl) {\n      this._fragmentEl = document.createDocumentFragment();\n    }\n\n    return this._fragmentEl;\n  }\n\n  get el() {\n    if (!this._el) {\n      this._el = this.fragmentEl.querySelector(':first-child');\n    }\n\n    return this._el;\n  }\n\n  on(event: string, fn) {\n    if (this.el) {\n      this.el.addEventListener(event, fn);\n      return;\n    }\n\n    this._eventsToBind[event] = this._eventsToBind[event] || [];\n    this._eventsToBind[event].push(fn);\n  }\n\n  trigger(event, data) {\n    if (!this.el) {\n      return;\n    }\n\n    const customEvent = new CustomEvent(event, { detail: data });\n    this.el.dispatchEvent(customEvent);\n  }\n\n  setState(state: Object) {\n    this.state = { ...this.state, ...state };\n    this.render();\n  }\n\n  render() {\n    render(this.template(this.state), this.fragmentEl);\n\n    const isRerendered = !this.el;\n    if (!isRerendered) {\n      this._bindEvents();\n    }\n\n    return this.fragmentEl;\n  }\n\n  renderTo(container) {\n    if (container instanceof HTMLElement) {\n      container.appendChild(this.render());\n    } else if (typeof container === 'string') {\n      document.querySelector(container).appendChild(this.render());\n    }\n\n    return this;\n  }\n\n  _bindEventsFromProps(props) {\n    Object.keys(props)\n      .filter(name => typeof props[name] === 'function')\n      .forEach(name => {\n        const matched = name.match(/(^on)([A-Z].*)/); //e.g. onClick, onActive\n        if (!matched) {\n          return;\n        }\n\n        const event = lcfirst(matched[2]);\n        this.on(event, props[name]);\n      });\n  }\n\n  _bindEvents() {\n    Object.keys(this._eventsToBind).forEach(event => {\n      this._eventsToBind[event].forEach(fn => {\n        this.on(event, fn);\n      });\n    });\n  }\n}\n","export { html, render, TemplateResult } from 'lit-html';\nexport { classMap } from 'lit-html/directives/class-map';\nexport { default as Component } from './Component';\n","import {Component, TemplateResult, html, classMap } from '../common';\nimport './Button.css';\n\nexport interface Props {\n  text: string;\n  type: 'normal' | 'submit';\n  isVisible?: boolean;\n  isDisabled?: boolean;\n}\n\nexport default class Button extends Component {\n  template({\n    text,\n    type = 'normal',\n    isVisible = true,\n    isDisabled = false\n  }: Props): TemplateResult {\n    const classes = {\n      'kuc-btn': true,\n      submit: type === 'submit',\n      normal: type === 'normal'\n    };\n\n    if (isVisible === false) {\n      return null;\n    }\n\n    return html`\n      <button class=${classMap(classes)} ?disabled=${isDisabled}>\n        ${text}\n      </button>\n    `;\n  }\n}\n","export { default } from './Button';","import { Component, TemplateResult, html } from '../common';\nimport './Text.css';\n\nexport interface Props {\n  value?: string | number;\n  isVisible?: boolean;\n  isDisabled?: boolean;\n  onChange?: Function;\n}\n\nexport default class Text extends Component {\n  template({\n    value = '',\n    isVisible = true,\n    isDisabled = false,\n    onChange\n  }: Props): TemplateResult {\n    if (isVisible === false) {\n      return null;\n    }\n    \n    return html`\n      <div class=\"kuc-input-outer\">\n        <input\n          class=\"kuc-input-text\"\n          type=\"text\"\n          value=${value}\n          \n          ?disabled=${isDisabled}\n        />\n      </div>\n    `;\n  }\n}\n","export { default } from './Text';","/**\n * @license\n * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport {AttributePart, directive, Part, PropertyPart} from '../lit-html.js';\n\nexport interface StyleInfo {\n  [name: string]: string;\n}\n\n/**\n * Stores the StyleInfo object applied to a given AttributePart.\n * Used to unset existing values when a new StyleInfo object is applied.\n */\nconst styleMapCache = new WeakMap<AttributePart, StyleInfo>();\n\n/**\n * Stores AttributeParts that have had static styles applied (e.g. `height: 0;`\n * in style=\"height: 0; ${styleMap()}\"). Static styles are applied only the\n * first time the directive is run on a part.\n */\n// Note, could be a WeakSet, but prefer not requiring this polyfill.\nconst styleMapStatics = new WeakMap<AttributePart, true>();\n\n/**\n * A directive that applies CSS properties to an element.\n *\n * `styleMap` can only be used in the `style` attribute and must be the only\n * expression in the attribute. It takes the property names in the `styleInfo`\n * object and adds the property values as CSS propertes. Property names with\n * dashes (`-`) are assumed to be valid CSS property names and set on the\n * element's style object using `setProperty()`. Names without dashes are\n * assumed to be camelCased JavaScript property names and set on the element's\n * style object using property assignment, allowing the style object to\n * translate JavaScript-style names to CSS property names.\n *\n * For example `styleMap({backgroundColor: 'red', 'border-top': '5px', '--size':\n * '0'})` sets the `background-color`, `border-top` and `--size` properties.\n *\n * @param styleInfo {StyleInfo}\n */\nexport const styleMap = directive((styleInfo: StyleInfo) => (part: Part) => {\n  if (!(part instanceof AttributePart) || (part instanceof PropertyPart) ||\n      part.committer.name !== 'style' || part.committer.parts.length > 1) {\n    throw new Error(\n        'The `styleMap` directive must be used in the style attribute ' +\n        'and must be the only part in the attribute.');\n  }\n\n  // Handle static styles the first time we see a Part\n  if (!styleMapStatics.has(part)) {\n    (part.committer.element as HTMLElement).style.cssText =\n        part.committer.strings.join(' ');\n    styleMapStatics.set(part, true);\n  }\n  const style = (part.committer.element as HTMLElement).style;\n\n  // Remove old properties that no longer exist in styleInfo\n  const oldInfo = styleMapCache.get(part);\n  for (const name in oldInfo) {\n    if (!(name in styleInfo)) {\n      if (name.indexOf('-') === -1) {\n        // tslint:disable-next-line:no-any\n        (style as any)[name] = null;\n      } else {\n        style.removeProperty(name);\n      }\n    }\n  }\n\n  // Add or update properties\n  for (const name in styleInfo) {\n    if (name.indexOf('-') === -1) {\n      // tslint:disable-next-line:no-any\n      (style as any)[name] = styleInfo[name];\n    } else {\n      style.setProperty(name, styleInfo[name]);\n    }\n  }\n  styleMapCache.set(part, styleInfo);\n});\n","import { html } from 'lit-html';\n\nexport const listItemTemplate = props => {\n  const _onClick = () => {\n    if (props.isDisabled) {\n      return false;\n    }\n    props.onClick(props.item);\n    return true;\n  };\n\n  const _onChange = () => {\n    if (props.isDisabled) {\n      return false;\n    }\n    props.onChange(props.item);\n    return true;\n  };\n\n  const generateGUID = () => {\n    return Math.floor((1 + Math.random()) * 0x10000)\n      .toString(16)\n      .substring(1);\n  };\n\n  if (props.isVisible === false) {\n    return null;\n  }\n\n  if (props.type === 'checkbox' || props.type === 'radio') {\n    const id =\n      new Date().getTime() +\n      '-' +\n      generateGUID() +\n      '-' +\n      generateGUID() +\n      generateGUID();\n    return html`\n      <span className=${props.className}>\n        <input\n          name=${props.name}\n          id=${id}\n          disabled=${props.isDisabled}\n          type=${props.type}\n          checked=${props.selected}\n          @change=${_onChange}\n        />\n        <label for=${id}>${props.item.label} </label>\n      </span>\n    `;\n  }\n\n  const className = [\n    'kuc-list-item',\n    props.selected ? 'kuc-list-item-selected' : '',\n    props.isDisabled ? 'kuc-list-item-disable' : ''\n  ];\n\n  return html`\n    <div\n      @click=${_onClick}\n      class=${className.join(' ').trim()}\n      .disabled=${props.isDisabled}\n    >\n      <span class=\"kuc-icon-check\"\n        ><i class=\"fa fa-check\" aria-hidden=\"true\"></i\n      ></span>\n      <span class=\"kuc-list-item-label\">${props.item.label}</span>\n    </div>\n  `;\n};\n\nexport default listItemTemplate;\n","export const handleItemClick = (item, onChange) => {\n  const value = item.value;\n  onChange(value);\n};\n\nexport const hasDuplicatedItems = items => {\n  const unique = {};\n  let isUnique = true;\n  if (items) {\n    items.forEach(val => {\n      if (typeof unique[val.value] !== 'undefined') {\n        isUnique = false;\n      }\n      unique[val.value] = 0;\n    });\n  }\n  return !isUnique;\n};\n\nexport const hasValidValue = (items, value) => {\n  if (value === undefined) {\n    return true;\n  }\n  return (\n    items &&\n    items.some(item => {\n      return item.value === value;\n    })\n  );\n};\n","import { styleMap } from 'lit-html/directives/style-map';\nimport { Component, html, classMap } from '../common';\nimport itemTemplate from '../common/list-item-template';\n// import Message from '../constant/Message';\nimport { handleItemClick } from '../common/selection-single';\n\nimport './Dropdown.css';\n\ninterface Item {\n  value: string | number;\n  label: string;\n  isDisabled?: boolean;\n}\n\ninterface Props {\n  value?: string | number;\n  items: Item[];\n  isVisible?: boolean;\n  isDisabled?: boolean;\n  isVisibleItems?: boolean;\n}\n\nexport default class Dropdown extends Component {\n  _showItems = () => {\n    this.setState({\n      isVisibleItems: true\n    });\n\n    document.addEventListener('click', this._hideItems);\n  };\n\n  _hideItems = evt => {\n    if (this.el.contains(evt.target)) {\n      return;\n    }\n\n    this.setState({ isVisibleItems: false });\n    document.removeEventListener('click', this._hideItems);\n\n    // TODO: fix to toggle the dropdown list\n  };\n\n  _onChange = value => {\n    this.setState({ value, isVisibleItems: false });\n    this.trigger('change', { value });\n  };\n\n  _getItemsStyle({ isVisibleItems, isDisabled }) {\n    const display =\n      isVisibleItems && !isDisabled\n        ? { display: 'block' }\n        : { display: 'none' };\n    return display;\n  }\n\n  template({ value, items, isVisible, isDisabled, isVisibleItems }: Props) {\n    if (isVisible === false) {\n      return null;\n    }\n\n    // TODO: fix it!\n    // if (AbstractSingleSelection._hasDuplicatedItems(this.state.items)) {\n    //   throw new Error(Message.common.SELECTTION_DUPLICATE_VALUE);\n    // }\n\n    // if (!AbstractSingleSelection._hasValidValue(this.state.items, this.state.value)) {\n    //   throw new Error(Message.common.INVALID_ARGUMENT);\n    // }\n\n    const renderItems = items => {\n      return items.map((item, i) => {\n        return itemTemplate({\n          selected: value === item.value,\n          onClick: item_prop => handleItemClick(item_prop, this._onChange),\n          item,\n          isDisabled: item.isDisabled\n        });\n      });\n    };\n\n    let index = -1;\n    items &&\n      items.forEach((item, i) => {\n        if (item.value === value) {\n          index = i;\n        }\n      });\n\n    const className = [\n      'kuc-dropdown',\n      isDisabled ? 'kuc-dropdown-disable' : ''\n    ];\n\n    return html`\n      <div class=\"kuc-dropdown-container\">\n        <div class=\"kuc-dropdown-sub-container\">\n          <div class=\"kuc-dropdown-outer\" @click=${this._showItems}>\n            <div class=${className.join(' ').trim()}>\n              <div class=\"kuc-dropdown-selected\">\n                <span class=\"kuc-dropdown-selected-name\">\n                  <span>${index !== -1 && items[index].label}</span>\n                  <span class=\"icon-arrow-down\"\n                    ><i class=\"fa fa-angle-down\" aria-hidden=\"true\"></i\n                  ></span>\n                </span>\n              </div>\n            </div>\n          </div>\n          <div\n            style=${styleMap(\n              this._getItemsStyle({ isVisibleItems, isDisabled })\n            )}\n            class=\"kuc-list-outer\"\n          >\n            ${items && renderItems(items)}\n          </div>\n        </div>\n      </div>\n    `;\n  }\n}\n","export { default } from './Dropdown';\n","import { html } from '../common';\n\nconst headerRowTemplate = ({ columns }) => {\n  return html`\n    <div class=\"kuc-table-thead\">\n      <div class=\"kuc-table-tr\">\n        ${columns.map(({ header = '', actions }) =>\n          !actions\n            ? html`\n                <div class=\"kuc-table-th\">\n                  <span class=\"kuc-header-label\">${header}</span>\n                </div>\n              `\n            : ''\n        )}\n      </div>\n    </div>\n  `;\n};\n\nexport { headerRowTemplate as default };\n","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport {DirectiveFn} from '../lib/directive.js';\nimport {createMarker, directive, NodePart, Part, removeNodes, reparentNodes} from '../lit-html.js';\n\nexport type KeyFn<T> = (item: T, index: number) => unknown;\nexport type ItemTemplate<T> = (item: T, index: number) => unknown;\n\n// Helper functions for manipulating parts\n// TODO(kschaaf): Refactor into Part API?\nconst createAndInsertPart =\n    (containerPart: NodePart, beforePart?: NodePart): NodePart => {\n      const container = containerPart.startNode.parentNode as Node;\n      const beforeNode = beforePart === undefined ? containerPart.endNode :\n                                                    beforePart.startNode;\n      const startNode = container.insertBefore(createMarker(), beforeNode);\n      container.insertBefore(createMarker(), beforeNode);\n      const newPart = new NodePart(containerPart.options);\n      newPart.insertAfterNode(startNode);\n      return newPart;\n    };\n\nconst updatePart = (part: NodePart, value: unknown) => {\n  part.setValue(value);\n  part.commit();\n  return part;\n};\n\nconst insertPartBefore =\n    (containerPart: NodePart, part: NodePart, ref?: NodePart) => {\n      const container = containerPart.startNode.parentNode as Node;\n      const beforeNode = ref ? ref.startNode : containerPart.endNode;\n      const endNode = part.endNode.nextSibling;\n      if (endNode !== beforeNode) {\n        reparentNodes(container, part.startNode, endNode, beforeNode);\n      }\n    };\n\nconst removePart = (part: NodePart) => {\n  removeNodes(\n      part.startNode.parentNode!, part.startNode, part.endNode.nextSibling);\n};\n\n// Helper for generating a map of array item to its index over a subset\n// of an array (used to lazily generate `newKeyToIndexMap` and\n// `oldKeyToIndexMap`)\nconst generateMap = (list: unknown[], start: number, end: number) => {\n  const map = new Map();\n  for (let i = start; i <= end; i++) {\n    map.set(list[i], i);\n  }\n  return map;\n};\n\n// Stores previous ordered list of parts and map of key to index\nconst partListCache = new WeakMap<NodePart, (NodePart | null)[]>();\nconst keyListCache = new WeakMap<NodePart, unknown[]>();\n\n/**\n * A directive that repeats a series of values (usually `TemplateResults`)\n * generated from an iterable, and updates those items efficiently when the\n * iterable changes based on user-provided `keys` associated with each item.\n *\n * Note that if a `keyFn` is provided, strict key-to-DOM mapping is maintained,\n * meaning previous DOM for a given key is moved into the new position if\n * needed, and DOM will never be reused with values for different keys (new DOM\n * will always be created for new keys). This is generally the most efficient\n * way to use `repeat` since it performs minimum unnecessary work for insertions\n * amd removals.\n *\n * IMPORTANT: If providing a `keyFn`, keys *must* be unique for all items in a\n * given call to `repeat`. The behavior when two or more items have the same key\n * is undefined.\n *\n * If no `keyFn` is provided, this directive will perform similar to mapping\n * items to values, and DOM will be reused against potentially different items.\n */\nexport const repeat =\n    directive(\n        <T>(items: Iterable<T>,\n            keyFnOrTemplate: KeyFn<T>|ItemTemplate<T>,\n            template?: ItemTemplate<T>):\n            DirectiveFn => {\n              let keyFn: KeyFn<T>;\n              if (template === undefined) {\n                template = keyFnOrTemplate;\n              } else if (keyFnOrTemplate !== undefined) {\n                keyFn = keyFnOrTemplate as KeyFn<T>;\n              }\n\n              return (containerPart: Part): void => {\n                if (!(containerPart instanceof NodePart)) {\n                  throw new Error('repeat can only be used in text bindings');\n                }\n                // Old part & key lists are retrieved from the last update\n                // (associated with the part for this instance of the directive)\n                const oldParts = partListCache.get(containerPart) || [];\n                const oldKeys = keyListCache.get(containerPart) || [];\n\n                // New part list will be built up as we go (either reused from\n                // old parts or created for new keys in this update). This is\n                // saved in the above cache at the end of the update.\n                const newParts: NodePart[] = [];\n\n                // New value list is eagerly generated from items along with a\n                // parallel array indicating its key.\n                const newValues: unknown[] = [];\n                const newKeys: unknown[] = [];\n                let index = 0;\n                for (const item of items) {\n                  newKeys[index] = keyFn ? keyFn(item, index) : index;\n                  newValues[index] = template !(item, index);\n                  index++;\n                }\n\n                // Maps from key to index for current and previous update; these\n                // are generated lazily only when needed as a performance\n                // optimization, since they are only required for multiple\n                // non-contiguous changes in the list, which are less common.\n                let newKeyToIndexMap!: Map<unknown, number>;\n                let oldKeyToIndexMap!: Map<unknown, number>;\n\n                // Head and tail pointers to old parts and new values\n                let oldHead = 0;\n                let oldTail = oldParts.length - 1;\n                let newHead = 0;\n                let newTail = newValues.length - 1;\n\n                // Overview of O(n) reconciliation algorithm (general approach\n                // based on ideas found in ivi, vue, snabbdom, etc.):\n                //\n                // * We start with the list of old parts and new values (and\n                // arrays of\n                //   their respective keys), head/tail pointers into each, and\n                //   we build up the new list of parts by updating (and when\n                //   needed, moving) old parts or creating new ones. The initial\n                //   scenario might look like this (for brevity of the diagrams,\n                //   the numbers in the array reflect keys associated with the\n                //   old parts or new values, although keys and parts/values are\n                //   actually stored in parallel arrays indexed using the same\n                //   head/tail pointers):\n                //\n                //      oldHead v                 v oldTail\n                //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n                //   newParts: [ ,  ,  ,  ,  ,  ,  ]\n                //   newKeys:  [0, 2, 1, 4, 3, 7, 6] <- reflects the user's new\n                //   item order\n                //      newHead ^                 ^ newTail\n                //\n                // * Iterate old & new lists from both sides, updating,\n                // swapping, or\n                //   removing parts at the head/tail locations until neither\n                //   head nor tail can move.\n                //\n                // * Example below: keys at head pointers match, so update old\n                // part 0 in-\n                //   place (no need to move it) and record part 0 in the\n                //   `newParts` list. The last thing we do is advance the\n                //   `oldHead` and `newHead` pointers (will be reflected in the\n                //   next diagram).\n                //\n                //      oldHead v                 v oldTail\n                //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n                //   newParts: [0,  ,  ,  ,  ,  ,  ] <- heads matched: update 0\n                //   and newKeys:  [0, 2, 1, 4, 3, 7, 6]    advance both oldHead\n                //   & newHead\n                //      newHead ^                 ^ newTail\n                //\n                // * Example below: head pointers don't match, but tail pointers\n                // do, so\n                //   update part 6 in place (no need to move it), and record\n                //   part 6 in the `newParts` list. Last, advance the `oldTail`\n                //   and `oldHead` pointers.\n                //\n                //         oldHead v              v oldTail\n                //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n                //   newParts: [0,  ,  ,  ,  ,  , 6] <- tails matched: update 6\n                //   and newKeys:  [0, 2, 1, 4, 3, 7, 6]    advance both oldTail\n                //   & newTail\n                //         newHead ^              ^ newTail\n                //\n                // * If neither head nor tail match; next check if one of the\n                // old head/tail\n                //   items was removed. We first need to generate the reverse\n                //   map of new keys to index (`newKeyToIndexMap`), which is\n                //   done once lazily as a performance optimization, since we\n                //   only hit this case if multiple non-contiguous changes were\n                //   made. Note that for contiguous removal anywhere in the\n                //   list, the head and tails would advance from either end and\n                //   pass each other before we get to this case and removals\n                //   would be handled in the final while loop without needing to\n                //   generate the map.\n                //\n                // * Example below: The key at `oldTail` was removed (no longer\n                // in the\n                //   `newKeyToIndexMap`), so remove that part from the DOM and\n                //   advance just the `oldTail` pointer.\n                //\n                //         oldHead v           v oldTail\n                //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n                //   newParts: [0,  ,  ,  ,  ,  , 6] <- 5 not in new map; remove\n                //   5 and newKeys:  [0, 2, 1, 4, 3, 7, 6]    advance oldTail\n                //         newHead ^           ^ newTail\n                //\n                // * Once head and tail cannot move, any mismatches are due to\n                // either new or\n                //   moved items; if a new key is in the previous \"old key to\n                //   old index\" map, move the old part to the new location,\n                //   otherwise create and insert a new part. Note that when\n                //   moving an old part we null its position in the oldParts\n                //   array if it lies between the head and tail so we know to\n                //   skip it when the pointers get there.\n                //\n                // * Example below: neither head nor tail match, and neither\n                // were removed;\n                //   so find the `newHead` key in the `oldKeyToIndexMap`, and\n                //   move that old part's DOM into the next head position\n                //   (before `oldParts[oldHead]`). Last, null the part in the\n                //   `oldPart` array since it was somewhere in the remaining\n                //   oldParts still to be scanned (between the head and tail\n                //   pointers) so that we know to skip that old part on future\n                //   iterations.\n                //\n                //         oldHead v        v oldTail\n                //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n                //   newParts: [0, 2,  ,  ,  ,  , 6] <- stuck; update & move 2\n                //   into place newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance\n                //   newHead\n                //         newHead ^           ^ newTail\n                //\n                // * Note that for moves/insertions like the one above, a part\n                // inserted at\n                //   the head pointer is inserted before the current\n                //   `oldParts[oldHead]`, and a part inserted at the tail\n                //   pointer is inserted before `newParts[newTail+1]`. The\n                //   seeming asymmetry lies in the fact that new parts are moved\n                //   into place outside in, so to the right of the head pointer\n                //   are old parts, and to the right of the tail pointer are new\n                //   parts.\n                //\n                // * We always restart back from the top of the algorithm,\n                // allowing matching\n                //   and simple updates in place to continue...\n                //\n                // * Example below: the head pointers once again match, so\n                // simply update\n                //   part 1 and record it in the `newParts` array.  Last,\n                //   advance both head pointers.\n                //\n                //         oldHead v        v oldTail\n                //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n                //   newParts: [0, 2, 1,  ,  ,  , 6] <- heads matched; update 1\n                //   and newKeys:  [0, 2, 1, 4, 3, 7, 6]    advance both oldHead\n                //   & newHead\n                //            newHead ^        ^ newTail\n                //\n                // * As mentioned above, items that were moved as a result of\n                // being stuck\n                //   (the final else clause in the code below) are marked with\n                //   null, so we always advance old pointers over these so we're\n                //   comparing the next actual old value on either end.\n                //\n                // * Example below: `oldHead` is null (already placed in\n                // newParts), so\n                //   advance `oldHead`.\n                //\n                //            oldHead v     v oldTail\n                //   oldKeys:  [0, 1, -, 3, 4, 5, 6] // old head already used;\n                //   advance newParts: [0, 2, 1,  ,  ,  , 6] // oldHead newKeys:\n                //   [0, 2, 1, 4, 3, 7, 6]\n                //               newHead ^     ^ newTail\n                //\n                // * Note it's not critical to mark old parts as null when they\n                // are moved\n                //   from head to tail or tail to head, since they will be\n                //   outside the pointer range and never visited again.\n                //\n                // * Example below: Here the old tail key matches the new head\n                // key, so\n                //   the part at the `oldTail` position and move its DOM to the\n                //   new head position (before `oldParts[oldHead]`). Last,\n                //   advance `oldTail` and `newHead` pointers.\n                //\n                //               oldHead v  v oldTail\n                //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n                //   newParts: [0, 2, 1, 4,  ,  , 6] <- old tail matches new\n                //   head: update newKeys:  [0, 2, 1, 4, 3, 7, 6]   & move 4,\n                //   advance oldTail & newHead\n                //               newHead ^     ^ newTail\n                //\n                // * Example below: Old and new head keys match, so update the\n                // old head\n                //   part in place, and advance the `oldHead` and `newHead`\n                //   pointers.\n                //\n                //               oldHead v oldTail\n                //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n                //   newParts: [0, 2, 1, 4, 3,   ,6] <- heads match: update 3\n                //   and advance newKeys:  [0, 2, 1, 4, 3, 7, 6]    oldHead &\n                //   newHead\n                //                  newHead ^  ^ newTail\n                //\n                // * Once the new or old pointers move past each other then all\n                // we have\n                //   left is additions (if old list exhausted) or removals (if\n                //   new list exhausted). Those are handled in the final while\n                //   loops at the end.\n                //\n                // * Example below: `oldHead` exceeded `oldTail`, so we're done\n                // with the\n                //   main loop.  Create the remaining part and insert it at the\n                //   new head position, and the update is complete.\n                //\n                //                   (oldHead > oldTail)\n                //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n                //   newParts: [0, 2, 1, 4, 3, 7 ,6] <- create and insert 7\n                //   newKeys:  [0, 2, 1, 4, 3, 7, 6]\n                //                     newHead ^ newTail\n                //\n                // * Note that the order of the if/else clauses is not important\n                // to the\n                //   algorithm, as long as the null checks come first (to ensure\n                //   we're always working on valid old parts) and that the final\n                //   else clause comes last (since that's where the expensive\n                //   moves occur). The order of remaining clauses is is just a\n                //   simple guess at which cases will be most common.\n                //\n                // * TODO(kschaaf) Note, we could calculate the longest\n                // increasing\n                //   subsequence (LIS) of old items in new position, and only\n                //   move those not in the LIS set. However that costs O(nlogn)\n                //   time and adds a bit more code, and only helps make rare\n                //   types of mutations require fewer moves. The above handles\n                //   removes, adds, reversal, swaps, and single moves of\n                //   contiguous items in linear time, in the minimum number of\n                //   moves. As the number of multiple moves where LIS might help\n                //   approaches a random shuffle, the LIS optimization becomes\n                //   less helpful, so it seems not worth the code at this point.\n                //   Could reconsider if a compelling case arises.\n\n                while (oldHead <= oldTail && newHead <= newTail) {\n                  if (oldParts[oldHead] === null) {\n                    // `null` means old part at head has already been used\n                    // below; skip\n                    oldHead++;\n                  } else if (oldParts[oldTail] === null) {\n                    // `null` means old part at tail has already been used\n                    // below; skip\n                    oldTail--;\n                  } else if (oldKeys[oldHead] === newKeys[newHead]) {\n                    // Old head matches new head; update in place\n                    newParts[newHead] =\n                        updatePart(oldParts[oldHead]!, newValues[newHead]);\n                    oldHead++;\n                    newHead++;\n                  } else if (oldKeys[oldTail] === newKeys[newTail]) {\n                    // Old tail matches new tail; update in place\n                    newParts[newTail] =\n                        updatePart(oldParts[oldTail]!, newValues[newTail]);\n                    oldTail--;\n                    newTail--;\n                  } else if (oldKeys[oldHead] === newKeys[newTail]) {\n                    // Old head matches new tail; update and move to new tail\n                    newParts[newTail] =\n                        updatePart(oldParts[oldHead]!, newValues[newTail]);\n                    insertPartBefore(\n                        containerPart,\n                        oldParts[oldHead]!,\n                        newParts[newTail + 1]);\n                    oldHead++;\n                    newTail--;\n                  } else if (oldKeys[oldTail] === newKeys[newHead]) {\n                    // Old tail matches new head; update and move to new head\n                    newParts[newHead] =\n                        updatePart(oldParts[oldTail]!, newValues[newHead]);\n                    insertPartBefore(\n                        containerPart, oldParts[oldTail]!, oldParts[oldHead]!);\n                    oldTail--;\n                    newHead++;\n                  } else {\n                    if (newKeyToIndexMap === undefined) {\n                      // Lazily generate key-to-index maps, used for removals &\n                      // moves below\n                      newKeyToIndexMap = generateMap(newKeys, newHead, newTail);\n                      oldKeyToIndexMap = generateMap(oldKeys, oldHead, oldTail);\n                    }\n                    if (!newKeyToIndexMap.has(oldKeys[oldHead])) {\n                      // Old head is no longer in new list; remove\n                      removePart(oldParts[oldHead]!);\n                      oldHead++;\n                    } else if (!newKeyToIndexMap.has(oldKeys[oldTail])) {\n                      // Old tail is no longer in new list; remove\n                      removePart(oldParts[oldTail]!);\n                      oldTail--;\n                    } else {\n                      // Any mismatches at this point are due to additions or\n                      // moves; see if we have an old part we can reuse and move\n                      // into place\n                      const oldIndex = oldKeyToIndexMap.get(newKeys[newHead]);\n                      const oldPart =\n                          oldIndex !== undefined ? oldParts[oldIndex] : null;\n                      if (oldPart === null) {\n                        // No old part for this value; create a new one and\n                        // insert it\n                        const newPart = createAndInsertPart(\n                            containerPart, oldParts[oldHead]!);\n                        updatePart(newPart, newValues[newHead]);\n                        newParts[newHead] = newPart;\n                      } else {\n                        // Reuse old part\n                        newParts[newHead] =\n                            updatePart(oldPart, newValues[newHead]);\n                        insertPartBefore(\n                            containerPart, oldPart, oldParts[oldHead]!);\n                        // This marks the old part as having been used, so that\n                        // it will be skipped in the first two checks above\n                        oldParts[oldIndex as number] = null;\n                      }\n                      newHead++;\n                    }\n                  }\n                }\n                // Add parts for any remaining new values\n                while (newHead <= newTail) {\n                  // For all remaining additions, we insert before last new\n                  // tail, since old pointers are no longer valid\n                  const newPart = createAndInsertPart(\n                      containerPart, newParts[newTail + 1]!);\n                  updatePart(newPart, newValues[newHead]);\n                  newParts[newHead++] = newPart;\n                }\n                // Remove any remaining unused old parts\n                while (oldHead <= oldTail) {\n                  const oldPart = oldParts[oldHead++];\n                  if (oldPart !== null) {\n                    removePart(oldPart);\n                  }\n                }\n                // Save order of new parts for next round\n                partListCache.set(containerPart, newParts);\n                keyListCache.set(containerPart, newKeys);\n              };\n            }) as\n    <T>(items: Iterable<T>,\n        keyFnOrTemplate: KeyFn<T>|ItemTemplate<T>,\n        template?: ItemTemplate<T>) => DirectiveFn;\n","import { html } from '../common';\n\nconst cellActionsTemplate = ({\n  data,\n  rowIndex,\n  addRow,\n  removeRow,\n  dispatch\n}) => {\n  return html`\n    <div class=\"kuc-table-td action-group\">\n      <button\n        @click=${() =>\n          dispatch({\n            type: 'ADD_ROW',\n            data: addRow({ data, rowIndex }),\n            rowIndex: rowIndex + 1\n          })}\n      >\n        Add\n      </button>\n      <button\n        @click=${() =>\n          dispatch({\n            type: 'REMOVE_ROW',\n            data: removeRow({ data, rowIndex }),\n            rowIndex: rowIndex\n          })}\n      >\n        Remove\n      </button>\n    </div>\n  `;\n};\n\nexport { cellActionsTemplate as default };\n","import { html } from '../common';\n\nconst cellTemplate = ({\n  rowData,\n  rowIndex,\n  accessor,\n  cell = cellProps => ''\n}) => {\n  const cellProps = { rowData, rowIndex };\n\n  const contentOrRenderer = accessor\n    ? getValueByAccessor(accessor, rowData)\n    : cell(cellProps);\n  let content;\n\n  if (!(contentOrRenderer && typeof contentOrRenderer.init === 'function')) {\n    content = contentOrRenderer;\n  }\n\n  return html`\n    <div class=\"kuc-table-td\">${content}</div>\n  `;\n};\n\nconst getValueByAccessor = (accessor, data) => {\n  switch (typeof accessor) {\n    case 'string':\n      return data[accessor];\n    case 'function':\n      return accessor(data);\n    default:\n      return '';\n  }\n};\n\nexport { cellTemplate as default };\n","import { repeat } from 'lit-html/directives/repeat';\nimport { html } from '../common';\nimport cellActionsTemplate from './cell-actions-template';\nimport cellTemplate from './cell-template';\n\nconst bodyTemplate = ({\n  columns,\n  data,\n  onChange,\n  keyField = '__tableRowId'\n}) => {\n  return html`\n    <div class=\"kuc-table-tbody\">\n      ${repeat(\n        data,\n        rowData => rowData[keyField],\n        (rowData, rowIndex) => {\n          return html`\n            <div class=\"kuc-table-tr\">\n              ${columns.map((column, columnIndex) => {\n                const { cell, accessor, actions } = column;\n\n                if (actions === true) {\n                  return cellActionsTemplate({\n                    data,\n                    rowIndex,\n                    addRow,\n                    removeRow,\n                    dispatch: newState => {\n                      onChange && onChange(newState);\n                    }\n                  });\n                }\n\n                return cellTemplate({\n                  rowData,\n                  rowIndex,\n                  accessor,\n                  cell\n                });\n              })}\n            </div>\n          `;\n        }\n      )}\n    </div>\n  `;\n};\n\nconst addRow = ({ data, rowIndex }) => {\n  const insertAt = rowIndex + 1;\n  const newData = [...data.slice(0, insertAt), {}, ...data.slice(insertAt)];\n  return newData;\n};\n\nconst removeRow = ({ data, rowIndex }) => {\n  return data.filter((item, index) => index !== rowIndex);\n};\n\nexport { bodyTemplate as default };\n","import { Component, html, classMap } from '../common';\nimport headerRowTemplate from './header-row-template';\nimport bodyTemplate from './body-template';\nimport './Table.css';\n\nexport default class Table extends Component {\n  constructor(props) {\n    super(props);\n\n    this._rowIdBuilder = rowIdBuilder(idGenerator());\n    this.state.data = this._rowIdBuilder.buildForList(props.data);\n    this._handleOnChange = this._handleOnChange.bind(this);\n    this._updateRowData = this._updateRowData.bind(this);\n    this._cellRefs = {};\n    this._cellsRenderer = props.columns.map(({ cell }) => cell);\n  }\n\n  template() {\n    const { data, columns, keyField } = this.state;\n\n    return html`\n      <div class=\"kuc-table\">\n        ${headerRowTemplate({ columns })}\n        ${bodyTemplate({\n          columns,\n          data,\n          onChange: this._handleOnChange,\n          keyField\n        })}\n      </div>\n    `;\n  }\n\n  render() {\n    const el = super.render();\n    this._renderCells();\n\n    return el;\n  }\n\n  _renderCells() {\n    const tableData = this.state.data;\n    const rowsEl = [\n      ...this.el.querySelectorAll('.kuc-table-tbody .kuc-table-tr')\n    ];\n    const isRenderer = renderer => typeof renderer === 'function';\n\n    rowsEl.forEach((rowEl, rowIndex) => {\n      const rowData = tableData[rowIndex];\n      const rowId = rowData.__tableRowId;\n      const updateRowData = this._updateRowData.bind(this, rowId);\n      const cellsEl = rowEl.querySelectorAll('.kuc-table-td');\n\n      this._cellsRenderer.forEach((renderer, index) => {\n        const cellEl = cellsEl[index];\n        if (!isRenderer(renderer)) {\n          return;\n        }\n\n        this._renderCell({\n          cellEl,\n          renderer,\n          rowData,\n          updateRowData,\n          rowIndex\n        });\n      });\n    });\n  }\n\n  _renderCell({ cellEl, renderer, rowData, updateRowData, rowIndex }) {\n    const table = this;\n    const cellRefs = this._cellRefs;\n    let cellInstance;\n\n    if (!cellRefs[cellEl.dataset.ref]) {\n      cellInstance = renderer();\n      const element = cellInstance.init({\n        table,\n        rowData,\n        rowIndex,\n        updateRowData\n      });\n      cellEl.appendChild(element);\n\n      cellEl.dataset.ref = Math.random();\n      cellRefs[cellEl.dataset.ref] = cellInstance;\n    }\n\n    cellInstance = cellRefs[cellEl.dataset.ref];\n\n    cellInstance.update({ table, rowData, rowIndex });\n  }\n\n  _handleOnChange({ type, data, rowIndex }) {\n    if (type === 'ADD_ROW') {\n      data[rowIndex] = this._rowIdBuilder.buildForObject(\n        { ...this.state.defaultRowData } || {}\n      );\n    }\n\n    this.setState({ data });\n    this.trigger('change', { data, type, rowIndex });\n  }\n\n  _updateRowData(rowId, rowDataToMerge) {\n    let rowIndex = 0;\n    const tableData = this.state.data.map((row, index) => {\n      if (row.__tableRowId === rowId) {\n        rowIndex = index;\n        return {\n          ...row,\n          ...rowDataToMerge\n        };\n      }\n\n      return row;\n    });\n\n    this.setState({ data: tableData });\n    this.trigger('change', { data: tableData, rowIndex });\n  }\n}\n\nconst idGenerator = () => {\n  let id = 0;\n\n  return {\n    get newId() {\n      return ++id;\n    }\n  };\n};\n\nconst rowIdBuilder = idGenerator => {\n  return {\n    buildForObject(obj) {\n      return {\n        ...obj,\n        __tableRowId: idGenerator.newId\n      };\n    },\n    buildForList(list) {\n      return list.map(item => this.buildForObject(item));\n    }\n  };\n};\n","export { default } from './Table';\n","import './Common/common.css';\n\nexport { default as Button } from './Button';\nexport { default as Text } from './Text';\nexport { default as Dropdown } from './Dropdown';\nexport { default as Table } from './Table';\n","/* global $ */\nimport { createSection } from './section';\nimport { Table } from '../../src';\n\nexport default container => {\n  const tableSection = createSection('Table').appendTo(container);\n  const table = new Table({\n    defaultRowData: {\n      x: 0,\n      color: { r: 255, g: 255, b: 255 },\n      startDate: new Date()\n    },\n    data: [\n      {\n        x: 0,\n        color: { r: 200, g: 230, b: 201 },\n        startDate: new Date(2018, 11, 10)\n      }\n    ],\n    columns: [\n      {\n        header: 'ID',\n        accessor: r => r.__tableRowId\n      },\n      {\n        header: 'Color (RGB)',\n        cell: () => rgbCell({ fieldName: 'color' })\n      },\n      {\n        header: 'Start Date',\n        cell: () => jqDateCell({ fieldName: 'startDate' })\n      },\n      {\n        header: 'End Date',\n        cell: () => jqDateCell({ fieldName: 'endDate', bgColor: '#B2DFDB' })\n      },\n      {\n        header: 'Output',\n        cell: () => outputCell()\n      },\n      {\n        actions: true\n      }\n    ]\n  });\n\n  tableSection.appendChild(table.render());\n};\n\nconst rgbCell = props => ({\n  init({ updateRowData }) {\n    const $el = $(`\n    <div style=\"white-space: nowrap\">\n      <div>R<input type=\"range\" name=\"r\" min=\"0\" max=\"255\" style=\"width: 70px\"/></div>\n      <div>G<input type=\"range\" name=\"g\" min=\"0\" max=\"255\" style=\"width: 70px\"/></div>\n      <div>B<input type=\"range\" name=\"b\" min=\"0\" max=\"255\" style=\"width: 70px\"/></div>\n    </div>\n    `);\n\n    $el\n      .find('input')\n      .each((index, inputEl) => (this[inputEl.name] = $(inputEl)));\n\n    $el.on('change', 'input', e => {\n      updateRowData({\n        [props.fieldName]: {\n          r: this.r.val(),\n          g: this.g.val(),\n          b: this.b.val()\n        }\n      });\n    });\n\n    return $el.get(0);\n  },\n\n  update({ rowData }) {\n    const color = rowData[props.fieldName] || {};\n    this.r.val(color.r);\n    this.g.val(color.g);\n    this.b.val(color.b);\n  }\n});\n\nconst jqDateCell = props => ({\n  init({ updateRowData }) {\n    const $datepicker = $('<input type=\"text\" />').datepicker();\n    const { fieldName, bgColor = '#FFF9C4' } = props;\n\n    $datepicker.css({ width: '70px', backgroundColor: bgColor });\n\n    $datepicker.on('change', () =>\n      updateRowData({\n        [fieldName]: $datepicker.datepicker('getDate')\n      })\n    );\n\n    this.$datepicker = $datepicker;\n\n    return $datepicker.get(0);\n  },\n\n  update({ rowData }) {\n    this.$datepicker.datepicker('setDate', rowData[props.fieldName] || '');\n  }\n});\n\nconst outputCell = () => ({\n  init({ rowData, rowIndex, updateRowData }) {\n    const $el = $(`\n    <div style=\"white-space: nowrap; font-size: 12px; padding: 5px\">\n      <div>Start: <span class=\"js_start\"></span></div>\n      <div>End: <span class=\"js_end\"></span></div>\n      <div>Color: <span class=\"js_color\"></span></div>\n    </div>\n    `);\n\n    this._$start = $el.find('.js_start');\n    this._$end = $el.find('.js_end');\n    this._$color = $el.find('.js_color');\n    this._$el = $el;\n\n    return $el.get(0);\n  },\n  update({ rowData: { startDate, endDate, color = {} } }) {\n    this._$start.text(\n      $.datepicker.formatDate('mm/dd/yy', startDate) || '(empty)'\n    );\n    this._$end.text($.datepicker.formatDate('mm/dd/yy', endDate) || '(empty)');\n\n    const colorArr = [color.r, color.g, color.b];\n    const rgbStr = 'rgb(' + colorArr.join() + ')';\n    this._$color.text(rgbStr);\n\n    this._$el.css({ backgroundColor: rgbStr });\n  }\n});\n","import { createSection } from './section';\nimport { Text, Button, Dropdown } from '../../src';\nimport tableExample from './table.js';\n\nconst mainEl = document.querySelector('main');\n\n// text box\nconst textboxSection = createSection('Textbox').appendTo(mainEl);\nconst txt1 = new Text();\ntxt1.on('input', ({ target }) => console.log('txt1:', target.value));\ntextboxSection.appendChild(txt1.render());\n\nconst txt2 = new Text({ value: 'read only', isDisabled: true });\ntextboxSection.appendChild(txt2.render());\n\n// button\nconst buttonSection = createSection('Button').appendTo(mainEl);\nconst btn1 = new Button({ text: 'Button 1' });\nbtn1.on('click', () => console.log('\"Button 1\" is clicked'));\nbuttonSection.appendChild(btn1.render());\n\nconst btn2 = new Button({ text: 'Button 2', type: 'submit' });\nbtn2.on('click', () => console.log('\"Button 2\" is clicked'));\nbuttonSection.appendChild(btn2.render());\n\nconst btn3 = new Button({ text: 'Button 3', isDisabled: true });\nbuttonSection.appendChild(btn3.render());\n\n// dropdown\nconst dropdownSection = createSection('Dropdown').appendTo(mainEl);\nconst dropdown1 = new Dropdown({\n  items: [\n    {\n      label: 'Orange',\n      value: 'Orange'\n    },\n    {\n      label: 'Banana',\n      value: 'Banana'\n    },\n    {\n      label: 'Lemon',\n      value: 'Lemon',\n      isDisabled: true\n    },\n    {\n      label: 'Apple',\n      value: 'Apple'\n    }\n  ],\n  value: 'Banana'\n});\ndropdown1.on('change', ({ detail }) =>\n  console.log(`The \"${detail.value}\" is selected.`)\n);\ndropdownSection.appendChild(dropdown1.render());\n\nconst dropdown2 = new Dropdown({\n  items: [\n    {\n      label: 'iPhone 6',\n      value: 'iPhone 6'\n    },\n    {\n      label: 'iPhone 7',\n      value: 'iPhone 7',\n      isDisabled: true\n    },\n    {\n      label: 'iPhone 8',\n      value: 'iPhone 8'\n    },\n    {\n      label: 'iPhone X',\n      value: 'iPhone X'\n    }\n  ],\n  value: 'iPhone X'\n});\ndropdown2.on('change', ({ detail }) =>\n  console.log(`The \"${detail.value}\" is selected.`)\n);\ndropdownSection.appendChild(dropdown2.render());\n\n// table\ntableExample(mainEl);"]}